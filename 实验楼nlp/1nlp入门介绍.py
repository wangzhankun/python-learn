
# coding: utf-8

# # 自然语言处理介绍及字符串操作

# ----

# ### 实验介绍

# 为了让你对自然语言处理有一定的了解，知道什么是自然语言处理，以及自然语言处理到底在做什么，本次实验会对自然语言处理有一个总体概述。另外，由于字符是自然语言处理最基本的操作单元，在自然语言处理当中有着十分重要的位置。而正则表达式又是字符串处理的好帮手，所以本次实验还会对字符串的 Python 操作以及正则表达式在自然语言处理当中的应用作介绍。

# ### 实验知识点

# - 什么是自然语言处理
# - Python 进行字符串操作
# - 正则表达式在 NLP 的应用

# ### 目录索引

# - <a href="#什么是自然语言处理">什么是自然语言处理</a>
# - <a href="#字符串操作">字符串操作</a>
# - <a href="#正则表达式">正则表达式</a>

# ----

# 做一个中文文本分类任务，首先要做的是文本的预处理，对文本进行分词和去停用词操作，来把字符串分割成词与词组合而成的字符串集合并去掉其中的一些非关键词汇（像是：的、地、得等）。再就是对预处理过后的文本进行特征提取。最后将提取到的特征送进分类器进行训练。因此，本系列实验，我们将会按照整个步骤，逐步来讲解每一个部分的内容。

# 本系列实验我们将会按着中文邮件分类项目的流程来介绍下面几部分内容：
# 1. 介绍一下什么是自然语言处理以及针对字符串的一些 Python 基础操作。
# 2. 介绍中文自然语言处理当中的一种简单分词方法：基于规则的分词方法。
# 3. 介绍一种更成熟也更科学的分词方法：基于隐马可夫模型的分词方法。
# 4. 介绍两种特征提取的方法：词袋模型和TF-IDF模型。
# 5. 介绍支持向量机分类器，并综合前面4个实验的内容，完成一个对中文邮件分类的实际项目。

# ### 什么是自然语言处理

# NLP（Natural Language Processing，自然语言处理）当中所谓的「自然」是为了与人造的语言（比如 C 语言， JAVA  等）区分开来，指自然形成的语言，即平时人们日常使用的交流的语言。「语言」则是人类区别其他动物的本质特性。在所有生物中，只有人类才具有语言能力。人类的多种智能都与语言有着密切的关系。人类的逻辑思维以语言为形式，人类的绝大部分知识也是以语言文字的形式记载和流传下来的。「处理」则指的是对自然语言的各种处理方法与运用。

# NLP 不仅是计算语言学的应用领域，还是计算机科学和人工智能（AI）领域的一个重要研究方向。NLP 主要研究人与计算机之间用自然语言进行有效通信的各种理论和方法。因此，又可以说 NLP 是一门集语言学、计算机科学、数学于一体的学科。

# 不过，NLP 虽然是与语言学有关， NLP 又与语言学那种纯粹的研究自然语言有所区别。语言学是以自然语言为研究对象，研究语言的性质、功能、结构、运用和历史发展以及其他与语言有关的问题。NLP 则是在于研究能有效实现人机间自然语言通信的计算机系统。

# 总的来说，自然语言处理可以概括为： 就是利用计算机的强大的运算能力，采用统计手段来对语言进行处理，然后获得需要的信息，以达到最终想要的目的，而使用各种方法的一门技术。

# #### NLP分类

# NLP 经过多年的发展与进步，从自然语言的角度出发，基本可以划分为两个部分：自然语言的理解和自然语言的生成。

# 自然语言理解是个综合的系统工程，涉及了很多细分的学科。

# - 代表声音的 **音系学**：语言中发音的系统化组织。
# 
# - 代表构词法的 **词态学**：研究单词构成以及相互之间的关系。
# 
# - 代表语句结构的 **句法学**：给定文本的那部分是语法正确的。
# 
# - 代表理解的语义 **句法学** 和 **语用学** ：给定文本的含义和目的是什么。

# 语言理解涉及语言、语境和各种语言形式的学科。但总的来说，自然语言理解又可以分为三个方面：

# 1. 词义分析
# 2. 句法分析
# 3. 语义分析

# 自然语言的生成则是从结构化的数据（可以通俗理解为自然语言理解分析后的数据）以读取的方式自动生成文本。主要有三个阶段：

# 1. 文本规划：完成结构化数据中的基础内容规划。
# 2. 语句规划：从结构化数据中组合语句来表达信息流。
# 3. 实现：产生语法通顺的语句来表达文本。

# #### 研究与应用

# NLP 在现在大火的 AI 领域有着十分丰富的应用。总体来说，自然语言处理的研究问题（主要）有下面几种：

# - 信息检索：对大规模文档进行索引。
# - 语音识别：识别包含口语在内的自然语言的声学信号转换成符合预期的信号。
# - 机器翻译：将一种语言翻译成另外一种语言。
# - 智能问答：自动回答问题。
# - 对话系统：通过多回合对话，跟用户进行聊天、回答、完成某项任务。
# - 文本分类：将文本自动归类。
# - 情感分析：判断某段文本的情感倾向
# - 文本生成：根据需求自动生成文本
# - 自动文摘：归纳，总结文本的摘要。

# #### 术语

# 为了使你更轻松的学习后面的一些 NLP 内容 ，下面介绍一些 NLP 的一些基础专业术语。

# - 分词：词是 NLP 中能够独立活动的有意义的语言成分。即使某个中文单字也有活动的意义，但其实这些单字也是词，属于单字成词。
# 
# - 词性标注：给每个词语的词性进行标注，比如  跑/动词、美丽的/形容词等等。 
# 
# - 命名实体识别：从文本中识别出具有特定类别的实体。像是识别文本中的日期，地名等等。
# 
# - 词义消歧：多义词判断最合理的词义。
# 
# - 句法分析：解析句子中各个成分的依赖关系。
# 
# - 指代消解：消除和解释代词「这个，他，你」等的指代问题。

# ### 字符串操作

# 字符作为文本类数据的基本单元，其在自然语言处理中的地位可以说是非常的重要。而且，大部分的自然语言处理任务都是从字符上着手，因此本次的实验将从下面这一些非常基础的 Python 字符串操作知识开始。

# - 统计子串出现的次数
# - 去除字符串
# - 拼接字符串
# - 比较
# - 字符串大小写转换
# - 翻转字符串
# - 查找字符串
# - 判断子串是否存在
# - 字符串代替
# - 检查字符串

# `.count()` 方法返回特定的子串在字符串中出现的次数。

# In[ ]:


seq = '12345,1234,123,12,1'
seq1 = '1'
a = seq.count(seq1)
a


# `.strip()`方法可以去除字符串首尾的指定符号。无指定时，默认去除空格符 `' '` 和换行符 `'\n'`。

# In[ ]:


seq = ' 我们正在使用实验楼，实验楼学会很多!'
seq.strip()


# In[ ]:


seq.strip('!')


# In[ ]:


seq.strip(' 我们')


# 有时候只想要去除字符串开头的某个字符串，但是字符串的末尾有一个同样的字符串并不需要去掉。这时候可以使用 `.lstrip()` 方法。

# In[ ]:


seq = '12321'
seq.lstrip('1')


# 同样，可以使用`.rstrip()` 方法来单独去除末尾的字符。

# In[ ]:


seq.rstrip('1')


# 经常会遇到需要将字符串拼接起来的情况，这时可以用运算符 `+` 来简单暴力的拼接。

# In[ ]:


seq1 = '实'
seq2 = '验'
seq3 = '楼'
seq = seq1 + seq2 + seq3
seq


# In[ ]:


seq1 = ''
seq = ['实', '验', '楼']

# 将seq里面的每个字符拼接起来
for n in seq:
    seq1 += n
seq1


# 需要将字符串用特定的符号拼接起来的字符的时候，可以用 `.join()` 方法来进行拼接。

# In[ ]:


seq = ['2018', '10', '31']
seq = '-'.join(seq)  # 用 '-' 拼接
seq


# In[ ]:


seq = ['实', '验', '楼']
seq = ''.join(seq)  # 用''空字符拼接
seq


# 当想要比较两个字符串的大小时，这里需要加载 operator 工具，它是 Python 的标准库。不需要额外下载，直接通过 `import` 调用即可。operator 从左到右第一个字符开始，根据设定的规则比较，返回布尔值（ True，False ）。

# 判断 a < b 型：

# In[ ]:


import operator
seq1 = '字符串1号'
seq2 = '字符串2号'
operator.lt(seq1, seq2)


# 除了使用 operator 之外，还有一种方法更简便: 直接使用运算符比较。

# 直接使用运算符比较 a < b:

# In[ ]:


seq1<seq2


# 可以看到两个结果是一致的。

# 判断 a <= b：

# In[ ]:


operator.le(seq1, seq2)


# In[ ]:


seq1<=seq2


# 判断 a == b：

# In[ ]:


operator.eq(seq1, seq2)


# In[ ]:


seq1==seq2


# 判断 a != b：

# In[ ]:


operator.ne(seq1, seq2)


# In[ ]:


seq1!=seq2


# 判断a > b：

# In[ ]:


operator.gt(seq1, seq2)


# In[ ]:


seq1>seq2


# 判断 a >=b：

# In[ ]:


operator.ge(seq1, seq2)


# In[ ]:


seq1>=seq2


# 因此，使用 Python 的 operator 标准库和运算符比较结果是一致的，可以直接用来比较字符串，这种方法更加直观和简便。

# 在处理英文类文本的时候会遇到需要将文本全部转化为大写或者小写的时候。使用 `.upper()` 和 `.lower()` 可以很方便的完成这个任务。

# 使用 `.upper()` 将文本转化为大写。

# In[ ]:


seq = 'appLE'
seq = seq.upper()
seq


# 使用 `.lower()`将文本转化为小写。

# In[ ]:


seq = 'APPle'
seq = seq.lower()
seq


# 为了查找到某段字符串当中某个子串的位置信息，有两种方法。一种是`.index` ，一种是 `.find`。 两种方法都可实现这个功能，不同的是 `index` 如果未找到的话，会报错，而 `find` 未找到的则会返回 `-1` 值。

# `.find()` 方法，在序列当中找到子串的起始位置。PS：第一个位置是 `0` 。

# In[ ]:


seq = '这个是一段字符串'
seq1 = '字符串'
seq.find(seq1)


# `.find()` 方法，字符串中不存在子串返回 `-1`

# In[ ]:


seq2 = '无'
seq.find(seq2)


# 接下来我们用`.index()`方法来试一试。

# In[ ]:


seq3 = '字符串'
seq.index(seq3)


# 下面这段代码会报错，因为 `.index()`方法如果没有找到子串，**会报错提醒：substring not found**。

# In[ ]:


seq4 = '无'
seq.index(seq4)


# 当想要切分字符串时，有两种常用的方法。第一种是直用序列截取的方法。这种方法十分的简单，就是根据顺序来截取序列上你想要的某些片段。

# 想要截取 ‘这是字符串’， 中的‘这是字符’的时候。`[0:4]` 中 `:` 左边的 `0` 的意思是从序列位置 0（从0开始数），`:` 右边的 `4` 意思是截取到第 4 个字符（但并不包括从零开始数的第 4 个字符）。这里字面理解起来有点绕，下面是几个例子试着自己感受一下。

# In[ ]:


seq = '这是字符串'
seq1 = seq[0:4]
seq1


# 截取某个字符的时候可以通过这样。

# In[ ]:


seq2 = seq[0]
seq2


# In[ ]:


seq3 = seq[1:4]
seq3


# 这里如果结合字符串拼接的操作,还能把截出来的字符串拼接起来。

# In[ ]:


seq = '小了白了兔'
a = seq[0]
b = seq[2]
c = seq[4]
seq1 = a+b+c
seq1


# 有的时候，需要把一个字符串按照某个字符切分开处理。比如‘今天天气很好，我们出去玩’，要把两句话以 `'，'`切开成两句话。`split()`函数可以完成这个操作,函数返回一个由切分好的字符串组成的列表。

# In[ ]:


seq = '今天天气很好，我们出去玩'
seq = seq.split('，')
seq


# In[ ]:


seq = '2018-11-11'
seq = seq.split('-')
seq


# In[ ]:


seq = 'I have an apple'
seq = seq.split(' ')
seq


# In[ ]:


seq = '号外！号外！特大新闻'
seq = seq.split('！')
seq


# 需要翻转字符串的时候,那么我们直接用序列操作，直接以上面截取序列的方法，但是按照逆向的来截取实现翻转。

# In[ ]:


seq = '12345'
seq = seq[::-1]
seq


# 遇到需要判断某子串在字符串中是否出现，并根据判断做出后续操作的情况。可以用 `in` 来作出判断，若存在则返回 `True`，不存在则返回 `False`，然后配合 `if` ，作出后续操作。

# In[ ]:


seq = 'abcdef'
'a' in seq


# In[ ]:


seq = '你的名字真好听！'
'的' in seq


# `in` 关键字可以用在任何容器对象上，判断一个子对象是否存在于容器当中，并不局限于判断字符串是否存在某子串，还可以用在其他容器对象例如 `list`，`tuple`，`set` 等类型。

# 举个例子，判断一个数是否在 `list` 中:

# In[ ]:


nums = [1, 2, 3, 4]
2 in nums


# 下面试着配合 `if` 来完成一个后续操作。

# In[ ]:


seq = 'abcd'
n = 0
if 'a' in seq:
    n += 1
n


# 有时需要把字符串中的某段字符串用另一段字符串代替，比如  2018-01-01  中的 `-` 用 `'/'` 代替。我们可以用到 `.replace(a,b)` ，他可以将某字符串中的 `a` 字符串 替换成 `b` 字符串。下面来实现一下。

# In[ ]:


seq = '2018-11-11'
seq = seq.replace('-', '/')
seq


# In[ ]:


seq = '等会你还要来做实验吗？'
seq = seq.replace('吗？', '哦！')
seq


# In[ ]:


seq = '小了白了兔'
seq = seq.replace('了', '')
seq


# 当遇到需要判断字符串是否以某段字符开头的时候。比如想要判断‘abcdefg’是否以 'a'开头。可以用 `.startswish()` 方法。

# In[ ]:


seq = 'abcdefg'
seq.startswith('a')


# In[ ]:


seq = '我在实验楼'
seq.startswith('me')


# 同样的方法，我们可以用 `.endswith()` 来确定字符串是否以某段字符串结尾。

# In[ ]:


seq = 'abcd'
seq.endswith('d')


# In[ ]:


seq = '我在实验楼'
seq.endswith('喽')


# 有时候，当想要检查字符串的构成，像是检查字符串是否由纯数字构成。

# In[ ]:


seq = 's123'
seq.isdigit()


# In[ ]:


seq = '123'
seq.isdigit()


# ### 正则表达式

# 首先这里想要说明一下，正则表达式不是 Python 的特有内容，在 C语言，Java 等编程语言当中也同样适用，python 用了同样的正则表达式规则标准。正则表达式是用于处理字符串的强大工具，它由一个特殊的字符序列构成一定的规则，根据这个规则可以帮你检查字符串是否与这个规则的字符串匹配。正则表达式的合理运用，常常可以事半功倍。

# 接下来，通过几个例子讲解正则表达式在自然语言处理当中的实际运用。

# 在下面这几个日期信息中，如果想要提取其中的年份信息：

# - A : 2018/01/01
# 
# - B : 2018-01-01
# 
# - C : 2018.01.01
# 
# - D :01/01/2018

# 观察A,B,C,D 四个人的输入，因为每个人输入习惯的不同，导致了格式方面的不统一。这个时候，我们无法通过 Python 提供的字符串前4位[0：4] 的方法来提取每段序列当中的年份信息。这时候，可以考虑用到正则表达式。我们设计一个正则表达式 `[0-9]{4}` ，这个正则表达式代表的是 `0到9` 的数字连续 `4` 次。

# #### 动手练习

# 不规则日期文本中的年份信息提取：

# Pyython 对于正则表达式的支持，一般是通过 re 模块来提供。re 模块是 Python 自带的标准库，直接 `import` 加载就可以了，不需要另外下载第三方库。

# 首先，我们需要通过 `re.compile()` 将编写好的正则表达式编译为一个实例。

# In[ ]:


# 加载 re 模块
import re

# 将正则表达式编写成实例
pattern = re.compile(r'[0-9]{4}')
pattern


# 然后我们对字符串进行匹配，并对匹配结果进行操作。这里，我们要用到的是 `re.search()` 方法。 这个方法是将正则表达式与字符串进行匹配，如果找到第一个符合正则表达式的结果，就会返回，然后匹配结果存入`group()`中供后续操作。

# In[ ]:


import re
pattern = re.compile(r'[0-9]{4}')

time = '2018-01-01'

# 用刚刚编译好的 pattern，去匹配 time
match = pattern.search(time)

# 匹配结果存放在group()当中的
match.group()


# 可以看到我们的正则表达式匹配到了 `2018` 这个符合我们规则（连续`4个字符` 都是 `0-9的数字`）的结果。 现在我们根据上面两段代码的内容，设计一个小程序来提取这种不规则日期当中的年份信息。

# In[ ]:


import re

pattern = re.compile(r'[0-9]{4}')

times = ('2018/01/01', '01/01/2019', '01.2017.01')

for time in times:

    match = pattern.search(time)

    if match:
        print('年份有：', match.group())


# re 模块的更多使用：

# 下面我们通过几个例子来体会一下 `re` 模块对于正则表达式的其他用法。

# `.findall()`：
# 
# 这个方法可以找到符合正则表达式的所有匹配结果。这里我们使用了 `\d` 规则的正则表达式，这个正则表达式可以替我们识别数字。

# In[ ]:


import re

pattern = re.compile(r'\d')

pattern.findall('o1n2m3k4')


# 同样的方法，我们编写一个 `\D` 正则表达式，这个可以匹配一个非数字字符。

# In[ ]:


pattern = re.compile('\D')

pattern.findall('1A2B3C4D')


#  `.match()` 方法与 `.search()` 方法类似，只匹配一次，并且只从字符串的开头开始匹配。同样，match 结果也是存在 `group()` 当中。

# In[ ]:


# 不止是规则，字符也是可以单独作为正则表达式使用。
pattern = re.compile('c')

pattern.match('comcdc').group()


# 下面我们试着用 `.match()` 来匹配字符串的末尾字符，**发现代码报错**。这是因为 `.match()` 只从开头匹配。若匹配不成功，则 `group()`不会有内容。

# In[ ]:


# 我们编写了字符 1 作为正则表达式去匹配。
pattern = re.compile('1')

pattern.match('abcdefg1').group()


# 从上面的内容可以看到，正则表达式有着不小的作用。不同的正则表达式，有着不同的效果。合理的使用正则表达式可以帮助我们快速的完成许多操作。

# 正则表达式的应用场景十分广泛：在去除网页类文本语料库中 html 符号，去除一些聊天的表情符号像是 Orz ，T_T 等等有着十分充分的应用。因此学会使用正则表达式，将会对自然语言处理实现有着不小的帮助。

# 本次实验，我们没有深入讲解正则表达式的具体编写规则。如果你想更加深入的了解正则表达式的内容，想更加好的学习正则表达式的用法，那么可以点击下面实验楼的 关于正则表达式的实验教学。
# 
# - [实验楼正则表达式实验](https://www.shiyanlou.com/courses/90)

# ### 实验总结

# 本此以什么是自然语言处理着手，介绍了自然语言处理的基本意义及应用。然后介绍了 Python 关于字符串的基本操作，最后是对正则表达式的介绍。

# **拓展阅读**：
# - [自然语言处理-百度百科](https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/365730?fr=aladdin)
# - [自然语言处理-维基百科](https://wiki.zzczm.tk/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86)
# - [实验楼 Python3 简明教程](https://www.shiyanlou.com/courses/596)
