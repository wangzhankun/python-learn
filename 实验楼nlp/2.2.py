#%% 
## 英文处理
# 英文文本词与词之间有空格或者标点符号，如果想要对这种普通的英文文本进行分词的话是不需要什么算法支撑，暴力拆分，即直接通过空格或者标点来将文本进行分开就可以完成英文分词。
#%%
a = 'I have an apple'
a1 = a.split(' ')
print(a1)
#%%
# 按照空格拆分一次
a2 = a.split(' ', 1)
print(a2)
#%%
# 按照have拆分一次
a3 = a.split('have', 1)
print(a3)

## 下面实现对英文文本的拆分
#%%
def tokenize_english_text(text):
    # 按照标点区分句子
    # 建立一个空集，作为函数返回值
    tokenized_text = []

    for data in text:
        tokenized_data = []
        # 以'.'分割整个句子
        for s in data.split('.'):
            # 以'?'分割
            for s1 in s.split('?'):
                for s2 in s1.split('!'):
                    for s3 in s2.split(','):
                        tokenized_data.extend(s4 for s4 in s3.split(' ') if s4 != '')

        tokenized_text.append(tokenized_data)
    
    return tokenized_text

a = ['i am a boy?i am a boy ! i am a boy,i', 'god is a girl', 'i love you!']
print(tokenize_english_text(a))

#%% [markdown]
## 中文分词
# 中文分词这个概念自提出以来，经过多年的发展，主要可以分为三个方法：机械分词方法，统计分词方法，以及两种结合起来的分词。基于统计的分词方法我们将放到下一个实验中讲解，本次实验我们将重点放在机械分词方法上。
# 机械分词方法又叫做基于规则的分词方法：这种分词方法按照一定的规则将待处理的字符串与一个词表词典中的词进行逐一匹配，若在词典中找到某个字符串，则切分，否则不切分。机械分词方法按照匹配规则的方式，又可以分为：**正向最大匹配法**，**逆向最大匹配法**和**双向匹配法**三种。
### 正向最大匹配法
# 正向最大匹配法（Maximum Match Method，MM 法）是指从左向右按最大原则与词典里面的词进行匹配。假设词典中最长词是m个字，那么从待切分文本的最左边取m个字符与词典进行匹配，如果匹配成功，则分词。如果匹配不成功，那么取 m−1个字符与词典匹配，一直取直到成功匹配为止。<br/>

# 例子：
# * 句子：中华民族从此站起来了
# * 词典：“中华”，“民族”，“从此”，“站起来了”
# 使用MM法分词
# - 第一步：词典中最长是 4 个字，所以我们将 “中华民族” 取出来与词典进行匹配，匹配失败。
# - 第二步：于是，去掉 “族”，以 “中华民” 进行匹配，匹配失败
# - 第三步：去掉 “中华民” 中的 “民”，以 “中华” 进行匹配，匹配成功。 
# - 第四步：在带切分句子中去掉匹配成功的词，待切分句子变成 “民族从此站起来了”。
# - 第五步：重复上面的第 1 - 4 步骤
# - 第六步：若最后一个词语匹配成功，结束。

### 逆向最大匹配法
# 逆向最大匹配法（ Reverse Maximum Match Method, RMM 法）的原理与正向法基本相同，唯一不同的就是切分的方向与 MM 法相反。逆向法从文本末端开始匹配，每次用末端的最长词长度个字符进行匹配。<br/>

# 因为基本原理与 MM 法一样，反向来进行匹配就行。所以这里对算法不再赘述。<br/>
